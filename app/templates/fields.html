{% extends "base.html" %}
{% block content %}
<h2>My Fields</h2>

<!-- Gate for unauthenticated / non-client users -->
<div id="gate" class="card" hidden>
  <p>You must be logged in as a <strong>client</strong> to manage fields.</p>
  <p><a class="btn" href="/login">Login</a></p>
</div>

<!-- Main content -->
<section id="content" hidden>
  <div class="card">
    <h3>Add a field</h3>
    <div class="form">
      <label>Field name
        <input id="fieldName" placeholder="e.g., North 40" />
      </label>
    </div>

    <div id="map" style="height:440px; margin:.5rem 0; border-radius:12px; overflow:hidden;"></div>

    <div style="display:flex;align-items:center;gap:1rem;flex-wrap:wrap;">
      <p style="margin:0"><strong>Area:</strong> <span id="area">0</span> ha</p>
      <div style="display:flex;gap:.5rem;flex-wrap:wrap;">
        <button class="btn" type="button" onclick="finishPolygon()">Finish polygon</button>
        <button class="btn btn-outline" type="button" onclick="undoPoint()">Undo last point</button>
        <button class="btn btn-outline" type="button" onclick="clearShape()">Clear</button>
        <button class="btn" type="button" onclick="saveField()">Save field</button>
      </div>
    </div>

    <p style="margin-top:.5rem;color:#555;">
      Tip: click to add vertices; click the <em>first point</em> or press <em>Finish polygon</em> to close.  
      Double-click also finishes on desktop.
    </p>
  </div>

  <div class="card" style="margin-top:1rem;">
    <h3>Your fields</h3>
    <div id="list">Loading…</div>
  </div>

  <div class="card" style="margin-top:1rem;">
    <h3>Request work for a field</h3>
    <form id="reqForm" class="form" onsubmit="return createRequest(event)">
      <div class="grid" style="grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap:.75rem;">
        <label>Field
          <select id="req_field" required></select>
        </label>
        <label>Listing (optional)
          <input id="req_listing" placeholder="Paste listing UUID (MVP)" />
        </label>
        <label>Desired date/time
          <input id="req_date" type="datetime-local" />
        </label>
        <label>Time window
          <select id="req_window">
            <option value="">—</option>
            <option>morning</option>
            <option>afternoon</option>
            <option>evening</option>
            <option>flexible</option>
          </select>
        </label>
      </div>
      <label>Notes
        <textarea id="req_notes" rows="2" placeholder="Anything providers should know…"></textarea>
      </label>
      <button class="btn" type="submit">Submit request</button>
    </form>
  </div>
</section>

<div id="msg" class="result" hidden></div>

<!-- Leaflet & Turf -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const API = "/api/v1";
let token = localStorage.getItem("token");

// map/draw state
let map, finalLayer, previewLayer, firstMarker;
let drawPoints = [];   // [[lon,lat], ...]
let drawn = null;      // GeoJSON Feature (Polygon)

function authHeaders(){ return token ? {"Authorization":"Bearer "+token} : {}; }
function show(el, yes=true){ el.hidden = !yes; }
function msgOk(t){ const m=document.getElementById("msg"); m.className="result ok"; m.hidden=false; m.textContent=t; }
function msgErr(t){ const m=document.getElementById("msg"); m.className="result error"; m.hidden=false; m.textContent=t; }

(async function init(){
  if(!token){ show(document.getElementById("gate"), true); return; }
  const me = await fetch(`${API}/auth/me`, { headers: authHeaders() }).then(r=>r.ok?r.json():null);
  if(!me || !me.is_client){ show(document.getElementById("gate"), true); return; }

  show(document.getElementById("content"), true);
  initMap();
  await loadFields();
})();

function initMap(){
  map = L.map('map', { zoomControl: true }).setView([40.0, -8.0], 7); // default view (PT-ish)
  map.doubleClickZoom.disable(); // so dbl-click reaches our handler
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution: '&copy; OSM'}).addTo(map);

  finalLayer = L.geoJSON(null).addTo(map);      // finalized polygon
  previewLayer = L.layerGroup().addTo(map);     // points & preview line

  // click to add points; click near first point to finish
  map.on('click', (e) => {
    if (drawn) return; // polygon already closed
    if (drawPoints.length) {
      const firstLL = L.latLng(drawPoints[0][1], drawPoints[0][0]);
      const dist = map.distance(e.latlng, firstLL);
      if (dist < 12) { finishPolygon(); return; } // within ~12m → close
    }
    addPoint(e.latlng);
  });

  // desktop: double-click to finish
  map.on('dblclick', () => { if (!drawn && drawPoints.length >= 3) finishPolygon(); });
}

function addPoint(latlng){
  drawPoints.push([latlng.lng, latlng.lat]); // store [lon,lat]
  renderPreview();
}

function renderPreview(){
  previewLayer.clearLayers();

  // First point marker (click to finish)
  if (drawPoints.length > 0) {
    const firstLL = L.latLng(drawPoints[0][1], drawPoints[0][0]);
    firstMarker = L.circleMarker(firstLL, { radius: 6 }).addTo(previewLayer);
    firstMarker.bindTooltip("Click here to finish", {direction: "top"});
    firstMarker.on('click', finishPolygon);
  }

  // Polyline connecting added points
  if (drawPoints.length >= 2) {
    const latlngs = drawPoints.map(p => [p[1], p[0]]);
    L.polyline(latlngs).addTo(previewLayer);
  }
}

function undoPoint(){
  if (drawPoints.length === 0) return;
  drawPoints.pop();
  if (drawPoints.length === 0 && firstMarker) { previewLayer.removeLayer(firstMarker); firstMarker = null; }
  renderPreview();
}

function finishPolygon(){
  if (drawPoints.length < 3) { msgErr("Need at least 3 points to make a polygon."); return; }
  const ring = [...drawPoints, drawPoints[0]];
  drawn = {
    type: "Feature",
    geometry: { type: "Polygon", coordinates: [ring] },
    properties: {}
  };

  finalLayer.clearLayers();
  previewLayer.clearLayers();
  if (firstMarker) { previewLayer.removeLayer(firstMarker); firstMarker = null; }
  L.geoJSON(drawn).addTo(finalLayer);

  // compute area (ha) & centroid
  try {
    const area_m2 = turf.area(drawn);
    const ha = area_m2 / 10000;
    document.getElementById("area").textContent = ha.toFixed(4);
    drawn.properties.centroid = turf.centroid(drawn).geometry;
  } catch { /* turf load issues? ignore gracefully */ }
}

function clearShape(){
  drawPoints = [];
  drawn = null;
  finalLayer.clearLayers();
  previewLayer.clearLayers();
  if (firstMarker) { previewLayer.removeLayer(firstMarker); firstMarker = null; }
  document.getElementById("area").textContent = "0";
}

async function saveField(){
  const name = document.getElementById("fieldName").value.trim();
  if(!name){ msgErr("Please enter a field name."); return; }
  if(!drawn){ msgErr("Finish the polygon first."); return; }

  const area_ha = Number(document.getElementById("area").textContent);
  const centroid = drawn?.properties?.centroid || null;

  const r = await fetch(`${API}/fields/`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify({ name, geojson: drawn, area_ha, centroid })
  });
  if(!r.ok){ const e = await safeJson(r); msgErr(e?.detail || "Save failed"); return; }
  msgOk("Field saved.");
  clearShape();
  document.getElementById("fieldName").value = "";
  await loadFields();
}

async function loadFields(){
  const list = document.getElementById("list");
  const sel = document.getElementById("req_field");
  list.textContent = "Loading…";
  sel.innerHTML = "";

  const r = await fetch(`${API}/fields/`, { headers: authHeaders() });
  if(!r.ok){ list.textContent = "Failed to load fields."; return; }
  const items = await r.json();

  // dropdown for requests
  items.forEach(f => {
    const opt = document.createElement("option");
    opt.value = f.id; opt.textContent = `${f.name} (${Number(f.area_ha).toFixed(2)} ha)`;
    sel.appendChild(opt);
  });

  if(!items.length){ list.innerHTML = "<p>No fields yet.</p>"; return; }

  const ul = document.createElement("ul");
  ul.style.margin = 0; ul.style.paddingLeft = "1.2rem";
  items.forEach(f => {
    const li = document.createElement("li");
    li.innerHTML = `<strong>${esc(f.name)}</strong> — ${Number(f.area_ha).toFixed(2)} ha
      <button class="btn btn-outline" style="margin-left:.5rem" onclick='deleteField("${f.id}")'>Delete</button>`;
    ul.appendChild(li);
  });
  list.innerHTML = "";
  list.appendChild(ul);
}

async function deleteField(id){
  if(!confirm("Delete this field?")) return;
  const r = await fetch(`${API}/fields/${id}`, { method: "DELETE", headers: authHeaders() });
  if(r.status !== 204){ const e = await safeJson(r); msgErr(e?.detail || "Delete failed"); return; }
  msgOk("Field deleted.");
  await loadFields();
}

async function createRequest(e){
  e.preventDefault();
  const field_id = document.getElementById("req_field").value;
  const listing = document.getElementById("req_listing").value.trim();
  const desired = document.getElementById("req_date").value; // ISO from datetime-local
  const window = document.getElementById("req_window").value;
  const notes = document.getElementById("req_notes").value.trim() || null;

  const payload = {
    field_id,
    listing_id: listing || null,
    desired_date: desired || null,
    time_window: window || null,
    notes
  };

  const r = await fetch(`${API}/requests/`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...authHeaders() },
    body: JSON.stringify(payload)
  });
  if(!r.ok){ const e = await safeJson(r); msgErr(e?.detail || "Request failed"); return false; }
  msgOk("Request submitted. Providers can now quote.");
  e.target.reset();
  return false;
}

function esc(s){ return String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
async function safeJson(r){ try{ return await r.json(); }catch{ return null; } }
</script>
{% endblock %}
